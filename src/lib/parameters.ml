open Nonstd
module String = Sosa.Native_string


type t = {
  (* SAMPLES *)
  normal_inputs: Input.t list; [@docs "SAMPLES"]
    [@conv (Input.conv ~kind:"normal")]
  (** Normal sample(s) for the pipeline. *)
  tumor_inputs: Input.t list; [@docs "SAMPLES"]
    [@conv (Input.conv ~kind:"tumor")]
  (** Tumor sample(s) for the pipeline. *)
  rna_inputs: Input.t list option; [@docs "SAMPLES"]
    [@conv (Input.conv ~kind:"rna")]
  (** RNA sample(s) for the pipeline. *)

  (* OPTIONS *)
  reference_build: string;
  (** The reference build *)
  results_path: string;
  (** Where to save the results. *)
  java_max_heap: string option;
  (** Max Java heap size used for Picard & GATK tools e.g. 8g, 256m. *)
  igv_url_server_prefix: string option [@env "IGV_URL_SERVER_PREFIX"];
  (** URL with which to prefix igvxml paths. *)
  realign_bams: bool [@default true]
      [@name "without-realigning-bams"];
  (** Don't realign input BAMs. *)
  use_bwa_mem_opt: bool [@default true]
      [@name "without-bwa-mem-optimized"];
  (** Don't use the optimized workflow-node for bwa-mem
      (i.e. bam2fq + align + sort + to-bam). *)
  experiment_name: string [@main] [@cmdliner.pos 0];
  (** Give a name to the run(s). *)
  mhc_alleles: string list option; [@docv "ALLELE1,ALLELE2,..."]
  (** Run epitope binding prediction pipeline with the given list
      of MHC alleles in lieu of those generated by Seq2Hla or
      OptiType. *)
  without_cosmic: bool; [@default false]
  (** Don't pass cosmic to Mutect (no COSMIC). *)
  vaxrank_include_mismatches_after_variant: bool; [@default false]
  (** Vaxrank option: Ignore mismatches after variant. *)
  bedfile: string option; [@aka ["filter-vcfs-to-region-with"]]
  (** Run bedtools intersect on VCFs with the given bed file. file://... or
      http(s)://... *)
  binding_predictor: Biokepi_run_environment.Hla_utilities.predictor_type;
    [@show.opaque]
      (* TODO: Didn't write a formatter for this, so ppx_deriving_show doesn't
         know how to print it. Hence @opaque. *)
    [@default `NetMHCcons]
    [@enum
      ["netmhcpan", `NetMHCpan ; "netmhccons", `NetMHCcons;
       "random", `Random; "netmhc", `NetMHC]]
  (** Which binding predictor to use for Vaxrank and Topiary. *)

  (* NOTIFICATIONS: *)
  email_options: Qc.EDSL.email_options option [@term Qc.EDSL.cmdliner_term];
  (** Email options for notifications. *)

  (* OTHER TOOLS *)
  with_kallisto: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `kallisto`. *)
  with_topiary: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `topiary`. *)
  with_seq2hla: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `seq2hla`. *)
  with_mutect2: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `mutect2`. *)
  with_varscan: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `varscan`. *)
  with_somaticsniper: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `somaticsniper`. *)
  with_optitype_normal: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `optitype-normal`. *)
  with_optitype_tumor: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `optitype-tumor`. *)
  with_optitype_rna: bool [@docs "OTHER TOOLS"] [@default false];
  (** Also run with `optitype-rna`. *)
  with_bqsr: bool [@default true] [@docs "OTHER TOOLS"]
      [@name "without-bqsr"];
  (** Run without `BQSR`. *)
  with_indel_realigner: bool [@default true] [@docs "OTHER TOOLS"]
      [@name "without-indel-realigner"];
  (** Run without `indel-realigner`. *)
  with_mark_dups: bool [@default true] [@docs "OTHER TOOLS"]
      [@name "without-mark-dups"];
  (** Run without `mark-dups`. *)
} [@@deriving cmdliner,show,make]


let construct_run_name params =
  let {normal_inputs;  tumor_inputs; rna_inputs;
       experiment_name; reference_build; _} = params in
  String.concat ~sep:"-" [
    experiment_name;
    sprintf "%dnormals" (List.length normal_inputs);
    sprintf "%dtumors" (List.length tumor_inputs);
    begin
      match rna_inputs with
        None -> "" |
        Some is -> sprintf "%drnas" (List.length is) end;
    reference_build;
  ]


(* To maximize sharing the run-directory depends only on the experiment name
   (to allow the use to force a fresh one) and the reference-build (since
   Biokepi does not track it yet in the filenames). *)
let construct_run_directory param =
  sprintf "%s-%s" param.experiment_name param.reference_build


(** This sets the reference_build of the BAMs (if the input are BAMs), and
    represents the BAM (if it's a BAM) as a FASTQ (so that it'll be
    automatically converted to a FASTQ and realigned), if `realign_bam=true` in
    the Paramaters.t. If these are FASTQs, it leaves them alone.

    This is necessary because some information for processing these inputs are
    passed along with them in the CLI, so we don't have the information at CLI
    parsing time, and must set it when running the pipeline. *)
let normalize_inputs
    ({ normal_inputs; tumor_inputs; rna_inputs;
       realign_bams; reference_build;
       _ } as params) =
  let normalize_input i =
    let open Input in
    match i with
    | Bam ({ bam_sample_name; path; how; _ } as bam) ->
      begin match realign_bams with
      | true -> Fastq {
          fastq_sample_name = bam_sample_name;
          files = [None, Of_bam (how, None, reference_build, path)]
        }
      | false -> Bam { bam with reference_build }
      end
    | Fastq _ -> i
  in
  let normal_inputs = List.map ~f:normalize_input normal_inputs in
  let tumor_inputs = List.map ~f:normalize_input tumor_inputs in
  let rna_inputs =
    Option.map rna_inputs (fun rs -> List.map ~f:normalize_input rs) in
  { params with normal_inputs; tumor_inputs; rna_inputs; }


let metadata t = [
  "MHC Alleles",
  begin match t.mhc_alleles  with
  | None  -> "None provided"
  | Some l -> sprintf "Alleles: [%s]" (String.concat l ~sep:"; ")
  end;
  "Reference-build", t.reference_build;
  "Normal-inputs",
  List.map ~f:Input.to_string (t.normal_inputs) |> String.concat;
  "Tumor-inputs",
  List.map ~f:Input.to_string (t.tumor_inputs) |> String.concat;
  "RNA-inputs",
  Option.value_map
    ~default:"none"
    ~f:(fun r -> List.map ~f:Input.to_string r |> String.concat)
    (t.rna_inputs);
]
